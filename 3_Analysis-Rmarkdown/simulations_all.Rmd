---
title: "Simulations"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(fitdistrplus)
library(DescTools)
library(data.table)
library(dplyr)
library(reshape2)
library(RColorBrewer)
library(ggpubr) #ggarrange()
```


## Probability Law Functions
The probability of having $K$ total positives in a pool of size $n$ is the probability of $k$ being infected in the community (probability of infection equals prevalence) and $K-k$ being infected via network transmission (probability of infection equals $\tau$).
$$
P(\sum Y_i = K) = 
     \sum_{k=1}^K \left( {n \choose k} \pi^k (1-\pi)^{n-k} {n-k \choose K- k} (1-(1-\tau)^k)^{K-k} ((1-\tau)^k)^{(n-K)} \right)
$$
Functions for computing the probability of $K$ positives in a pool of size $N$, and to sample $\pi$ and $\tau$ from prior distributions, are in the `prob_laws_429.R` script. 
```{r}
source("prob_laws_528.R")
```

## Data preparation for doing simulations
### Load real Ct data and extract the distribution parameters
```{r}
# Get all tests
tests <- data.table::fread("alltests_1mar24jun_v1.csv")

# Keep only valid positive ct values for first tests
tests %>% filter(result == "positive", firsttest==TRUE,!is.na(cttarget)) %>% pull(cttarget) -> cts

# Fit Weibull Distribution
fw <- fitdist(cts, "weibull")
```

```{r}
## GENERATE Ct DATA
# Add variable of proportion Ct value >LoD to model, as surrogate for differences in viral load distribution in different populations

# Number of replicates to generate ecdf offset values for above.
set.seed(42)
x<-5000

# Create simulated vector of ct values with same shape as that from Weibull distribution fit to ct values from real first tests
# 5000 draws from weibull with shape and scale parameters drawn from real data
ct_fake_input <- rweibull(x,fw[[1]][1],fw[[1]][2]) 

# Create matrix of desired input parameters
# Change above.lod to % samples with ct value >LoD to reflect actual population of interest. Changing "lod" itself has no effect on model output.
lod <- 35
above.lod <- seq(0.05,0.3,0.05)
translation_vector <- seq(-10,15,0.01)
mat<-matrix(ncol=3,nrow=length(translation_vector))

# Loop 1: fix LOD; for known shift, what percent of samples are above LoD (a)? 
for(v in 1:length(translation_vector)){
  i=1 
  fn<-ecdf(subset(pmax(5,ct_fake_input+translation_vector[v]),
                  (pmax(5,ct_fake_input+translation_vector[v]))<45)) ## selects adequate values within the sample
			a<-1-fn(lod) ## percent of cvalues in the distribution above the LoD 
			mat[(v-1)+i,1]<-lod
			mat[(v-1)+i,2]<-a
			mat[(v-1)+i,3]<-translation_vector[v]
}

# Shift ct values for each LoD and %above lod
mat2<-matrix(ncol=3,nrow=length(above.lod))

# Loop 2: fix LOD; for known a, how much should you shift? 
for(j in 1:length(above.lod)){
	tmp<-subset(mat,mat[,1]==lod)
	u<-tmp[which.min(abs(above.lod[j]-tmp[,2])),3]
	mat2[j,1]<-lod[i]
	mat2[j,2]<-above.lod[j]
	mat2[j,3]<-u
}
```

### Include the probit  coefficients
The probits scores are necessary to compute the viral load. Specimens with Ct beyond (greater than) the LoD are assigned a decreasing probability of detection based on a probit regression curve. Probability of detection is derived form the probit regression model. 
```{r}
# probit data input
probit_input <- read.csv("probit_zscores_cts_tissue_agnostic.csv")
probit_t<-subset(probit_input,probit_input$z_value<=1.96 & probit_input$z_value>=-1.96)
probit<-probit_t[,c(2,4,3)]
probit<-probit[order(probit$z_value,probit$ct_value),]
z_scores<-as.numeric(unlist(distinct(probit,z_value)))

# Number of replicates for model
set.seed(42)
# n <- 10000

probit.mode<-c("base","dsa.lower","dsa.upper","psa") 
probit.mode.index<-1 # 1 = no variation, 2, = LLN, 3 = ULN, 4 = probabilistic
probit.z.indices<-c(488,1,length(z_scores)) # 488 is a z score of 0 (base case) in the z index vector
dilution.vary.index<-1 # 1 = no variation, 2 = probabilistic
```

### Compute Sensitivity of Test in Pooled Samples
Sensitivity is a funciton of the Ct values of the sample, which changes as a function of the number of positives in a pool of a given size (dilution). Import the function to compute sensitivity of the PCR tet on pooled samples, for a pool of size N with 1:N positives in the pool.
```{r}
source("sensitivity_fxn_429.R")
# default inputs into sens_fxn() are
# N, B = 1000, above = 5, ct_dat = ct_fake_input

sens_dat <- data.frame(do.call(rbind, sapply(1:20, function(n) { sens_fxn(n)})))
sens_dat$pos_frac <- sens_dat$positives / sens_dat$pool.size
#probit %>% filter(z_value == 0) %>% group_by(ct_value) %>% summarise(mean = mean(probit_probability_detection))
```

## Simulation: Metrics of interest for Pooled Testing

### Load Tau and Pi Dist Data
```{r}
pi_dist <- read.csv("select_pidist.csv")
tau_dist <- read.csv("sar_select.csv")

# clean up a few things for later plotting
tau_dist$Setting_specific <- with(tau_dist, paste0(Setting, " ", Notes))
tau_dist$Setting_specific[tau_dist$Setting_specific == "Healthcare healthcare"] <- "Healthcare"
tau_dist$Setting_specific[tau_dist$Setting_specific == "Household sc_calculated"] <- "Household General"
```


Compute metrics of interest (PPA, sensitivity, tests, etc) for each combination of pool size, prevalence, and tau. 
Also save a data frame with information about the comuted probabilities. 
```{r}
it =1
pool.max<-30 # maximum pool size
B <- 100 # number of simulations

for (N in 1:pool.max){
  #N <- 10
  for (p in 1:nrow(pi_dist)){
    #p <- 1
    prev_alpha <- pi_dist$alpha[p]
    prev_beta <- pi_dist$beta[p]
    prev <- prev_alpha/(prev_alpha + prev_beta) # mean of beta dist
    for(t in 1:nrow(tau_dist)){
      #t <- 1
      tau_alpha <- tau_dist$alpha[t]
      tau_beta <- tau_dist$beta[t]
      tau <- tau_alpha/(tau_alpha + tau_beta)
      print(c(prev_alpha, prev_beta, tau_alpha, tau_beta, N))
      a = list(proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=NULL,
                          prev_graph_effect=NULL,
                          null_mod = NULL,
                          null_mod_prev_graph=NULL,
                          B=B),
               proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=tau_graph_effect,
                          prev_graph_effect=NULL,
                          null_mod = NULL,
                          null_mod_prev_graph=NULL,
                          B=B),
               proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=NULL,
                          prev_graph_effect=prev_graph_effect,
                          null_mod = NULL,
                          null_mod_prev_graph=NULL,
                          B=B),
               proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=tau_graph_effect,
                          prev_graph_effect=prev_graph_effect,
                          null_mod = NULL,
                          null_mod_prev_graph=NULL,
                          B=B), 
               proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=NULL,
                          prev_graph_effect=NULL,
                          null_mod = TRUE,
                          null_mod_prev_graph=NULL,
                          B=B),
               proba_laws(N, prev, prev_alpha, prev_beta, 
                          tau, tau_alpha, tau_beta,
                          tau_graph_effect=NULL,
                          prev_graph_effect=NULL,
                          null_mod = NULL,
                          null_mod_prev_graph=TRUE,
                          B=B)
      )
      
      names = c("Fixed", "Tau Graph Effect","Pi Graph Effect","All Graph Effect", "Null Model (Fixed)", "Null Model (Pi Graph Effect)")
      for (n in 1:length(names)){
        prob_dat = data.frame(
            prob = t(sapply(1:B, function(b){a[[n]][,b]})),
            type = names[n], 
            pool_size = N, 
            prev = prev, 
            tau = tau) 
        
        sens <- data.frame(sens_fxn(N)) # prob(test positive | sum(Y_i) = k)
        sens <- sens$mean 
        sens_indiv <- data.frame(sens_fxn(1))$mean
        prob_pos <- sapply(1:B, function(b){sum(a[[n]][2:(N+1), b] * sens)}) 
        # a[[n]][2:(N+1), b] is the vector of probabilities (for the bth simulation)
        # of having 1:N positives in a pool of size N
        
        if (it ==1){
          prob_dat_long = reshape2::melt(prob_dat,
                                        # ID variables - all the variables to keep but not split apart on
                                        id.vars=c("type", "pool_size", "prev", "tau"),
                                        # The source columns are all remaining columns
                                        # Name of the destination column that will identify the original
                                        # column that the measurement came from
                                        variable.name="num_pos",
                                        value.name="prob_pos")
          prob_dat_long$num_pos <- rep(0:N, each = B)
          prob_dat_long$prob_test_pos <- prob_pos
          check <- data.frame(prob_sum = (1/B)*sum(prob_dat_long[,"prob_pos"]), 
                              good = ifelse((1/B)*sum(prob_dat_long[,"prob_pos"]) == 1, 1, 0),
                              type = names[n], 
                              pool_size = N, 
                              prev = prev, 
                              tau = tau)
          
          res = data.frame(
            sensit = sapply(1:B, function(b){
              sum(a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b])}), #sensitivity
            
            ppa = sapply(1:B, function(b){
              (sum(a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b]))/sens_indiv}),
            
            num_tests = (1/N) + prob_pos,
            
            caught_cases = sapply(1:B, function(b){
              (sum(c(1:N)*a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b]))})/((1/N) + prob_pos),
            
            missed_cases_persample = sapply(1:B, function(b){ # missed cases per sample
              (sum(c(1:N)*a[[n]][2:(N+1), b] * (1-sens)))})/((1/N) + prob_pos),
            
            type = names[n], 
            pool_size = N, 
            prev = prev,
            prev_param = pi_dist$alpha_beta[p],
            prev_setting = pi_dist$state_date[p],
            tau = tau,
            tau_param = tau_dist$alpha_beta[t], 
            tau_setting = tau_dist$Setting_specific[t])
        }else{
          temp <- reshape2::melt(prob_dat,
                                 id.vars=c("type", "pool_size", "prev", "tau"),
                                 variable.name="num_pos",
                                 value.name="prob_pos")
          temp$num_pos <- rep(0:N, each = B)
          temp$prob_test_pos <- prob_pos
          check_temp <- data.frame(prob_sum = (1/B)*sum(temp[,"prob_pos"]),
                                   good = ifelse((1/B)*sum(temp[,"prob_pos"]) == 1, 1, 0), 
                                   type = names[n], 
                                   pool_size = N, 
                                   prev = prev, 
                                   tau = tau)
          check <- rbind(check, check_temp)
          prob_dat_long = rbind(prob_dat_long, temp)
          
          res = rbind(res,
                      data.frame(sensit = sapply(1:B, function(b){
                        sum(a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b])}),
                        
                        ppa = sapply(1:B, function(b){
                          (sum(a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b]))/sens_indiv}),
                        
                        num_tests = (1/N) + prob_pos,
                        
                        caught_cases = sapply(1:B, function(b){
                          (sum(c(1:N)*a[[n]][2:(N+1), b] * sens)/sum(a[[n]][2:(N+1), b]))})/((1/N) + prob_pos),
                        
                        missed_cases_persample = sapply(1:B, function(b){ # missed cases per sample
                          (sum(c(1:N)*a[[n]][2:(N+1), b] * (1-sens)))})/((1/N) + prob_pos),
                        type = names[n], 
                        pool_size = N, 
                        prev = prev,
                        prev_param = pi_dist$alpha_beta[p],
                        prev_setting = pi_dist$state_date[p],
                        tau = tau,
                        tau_param = tau_dist$alpha_beta[t], 
                        tau_setting = tau_dist$Setting_specific[t]))
        }
        prob_dat <- NULL
        it = it + 1
      }
    }
  } 
}

#write.csv(res, "sim_may14.csv")
#write.csv(res, "sim_may8.csv") # max pool size 50, prev up to 0.02
#write.csv(res, "sim_may4.csv") # max pool size 20, prev up to 0.2
#write.csv(res, "sim_april29.csv")
# write.csv(res, "sim_march31.csv") # sampling tau from uniform distribution

# write.csv(res, "sim_march27.csv")
# write.csv(res, "sim_march29.csv")

#write.csv(res, "sim_may28.csv")

#write.csv(res, "sim_june1.csv")
#write.csv(prob_dat_long, "simprobs_june1.csv")
```


```{r}
#res <- read.csv("sim_may28.csv")
#res2 <- res
res <- read.csv("sim_june1.csv")
```


Calculate 95 percent (empirical) confidence intervals for metrics of interest
```{r}
conf_int <- res %>% 
  group_by(type, pool_size, tau, prev, tau_param, prev_param, prev_setting, tau_setting) %>% 
  summarise(sd_sens= sd(sensit), 
            sd_ppa = sd(ppa), 
            sd_tests = sd(num_tests), 
            sd_missed = sd(missed_cases_persample),
            mean_sens= mean(sensit), 
            mean_ppa = mean(ppa), 
            mean_tests = mean(num_tests), 
            mean_missed = mean(missed_cases_persample), 
            sens_q025 = quantile(sensit, probs=0.025), 
            sens_q975 = quantile(sensit, probs = 0.975), 
            ppa_q025 = quantile(ppa, probs=0.025), 
            ppa_q975 = quantile(ppa, probs = 0.975), 
            tests_q025 = quantile(num_tests, probs=0.025), 
            tests_q975 = quantile(num_tests, probs = 0.975), 
            missed_q025 = quantile(missed_cases_persample, probs=0.025), 
            missed_q975 = quantile(missed_cases_persample, probs = 0.975), 
            sens_fda = mean(sensit >= 0.85), 
            sens_fda_q025 = mean(sens_q025 >=0.85), 
            sens_fda_q975 = mean(sens_q975>=0.85))
conf_int$prev <- round(conf_int$prev, 3)
conf_int$tau <- round(conf_int$tau, 3)

# one row is duplicated
table(conf_int$type, conf_int$pool_size)
conf_int %>% filter(type == "Null Model (Pi Graph Effect)" & pool_size == 1 & tau == 0.124 & prev == 0.013)

conf_int <- conf_int %>% distinct(type, pool_size, tau, prev, tau_param, 
                      prev_param, prev_setting, tau_setting, 
                      .keep_all = TRUE)
#write.csv(conf_int, "sims_conf_int_june2.csv")
#conf_int <- read.csv("sims_conf_int_june2.csv")
```

```{r}
household_only <- conf_int %>% filter(tau_setting == "Household General")
conf_int <- conf_int %>% filter(tau_setting != "Household General")
```

# Investigate Probabilities and KL Divergence

# ####### --------- Data Visualization --------- ####### #

```{r}
path.out.figures <- "1_Figures" # Change to where to write output files to
```

## Visualize sensitivity 
## Plot Sensitivity as a function of number infected per pool
### Plot sensitivity as a function of Ct values
```{r}
# data frame of sensitivity as function of number positive per pool
# sens_plot1 <- ggplot(sens_dat, aes(x=pool.size, y=mean, group=as.factor(positives))) +
#   geom_line(aes(color=as.factor(positives))) + 
#   theme(legend.position="bottom") + 
#   guides(fill=guide_legend(title="Number Positive")) + 
#   geom_hline(yintercept = sens_dat$mean[sens_dat$pool.size==1]) + 
#   xlab("Pool size") + ylab("Sensitivity") 

# sensitivity as function of fraction of positives in pool
sens_plot1 <- ggplot(sens_dat, aes(x=pos_frac, y=mean, group=as.factor(pool.size))) +
  geom_line(aes(color=as.factor(pool.size))) + 
  guides(color=guide_legend(title="Pool Size")) + 
  geom_hline(yintercept = sens_dat$mean[sens_dat$pool.size==1]) + 
  theme(legend.position="bottom") + theme_bw()+
  xlab("Number Positive / Pool size") + ylab("Sensitivity") +
  ggtitle("Sensitivity vs. Fraction of Pool Positve")

# sensitivity as fxn of Ct values
sens_plot2 <- ggplot(sens_dat, aes(x=ct_avg, y=mean, group=as.factor(pool.size))) +
  geom_line(aes(color=as.factor(pool.size))) + 
  guides(color=guide_legend(title="Pool Size")) + 
  geom_hline(yintercept = sens_dat$mean[sens_dat$pool.size==1]) + 
  theme(legend.position="bottom") + theme_bw()+
  xlab("Average Ct Value") + ylab("") + 
  ggtitle("Sensitivity vs. Average Ct Value")

pdf(file.path(path.out.figures, "sensitivity_plots.pdf"),width=8, height=5)  
ggarrange(sens_plot1, sens_plot2, common.legend = TRUE, legend = "bottom")
dev.off()

```

### Plot probit probability of detection as a function of Ct values
```{r}
# Probit probability of detectin as fxn of Ct values
pdf(file.path(path.out.figures, "prob_detect.pdf"), width =8, height =5)
ggplot(probit %>% group_by(ct_value) %>% 
         summarize(probit_probability_detection = mean(probit_probability_detection)), 
       aes(x=ct_value, y=probit_probability_detection)) + 
  geom_point(color= "#C77CFF") + theme_bw() +
  xlab("Ct Value") + ylab("Probit Probability of Detection") + 
  ggtitle("Probability of Detection vs. Ct Value")
dev.off()
```



# Visualization of Simulation Results for Metrics of Interest
```{r}
# labels and factors for plotting
table(conf_int$type)
types <- factor(c("Null Model (Fixed)", "Null Model (Pi Graph Effect)", 
                  "All Graph Effect", "Fixed", "Pi Graph Effect", "Tau Graph Effect"), 
                levels = c("Null Model (Fixed)","Null Model (Pi Graph Effect)",
                           "All Graph Effect", "Fixed", "Pi Graph Effect", "Tau Graph Effect"))
conf_int$type <- factor(conf_int$type, 
                         levels = c("Null Model (Fixed)","Null Model (Pi Graph Effect)",
                           "All Graph Effect", "Fixed", "Pi Graph Effect", "Tau Graph Effect"))
lines <- c("Network Transmission" = "solid", "No Correlation" = "dashed")
lines_sensplots <- c("Network Transmission" = "solid", "No Correlation" = "dashed", 
                     "Individual Testing" = "dotdash", "FDA Threshold" = "dotted")

conf_int$prev_labels <- paste(100*conf_int$prev, "%", conf_int$prev_setting)
table(conf_int$prev_labels)
require(graphics)
conf_int$prev_labels <- factor(conf_int$prev_labels, 
                               levels = c("0.2 % Maine Oct 2020", 
                                          "0.4 % Idaho May 2021",
                                          "0.5 % Oregon Apr 2021",
                                          "1.3 % Georgia Jul 2020",
                                          "3.4 % Iowa Nov 2020",
                                          "5.4 % Alabama Jan 2021"),
                               labels= c(expression("0.2 % \n Maine Oct 2020"),
                                         expression("0.4 % \n Idaho May 2021"),
                                         expression("0.5 % \n Oregon Apr 2021"),
                                         expression("1.3 % \n Georgia Jul 2020"),
                                         expression("3.4 % \n Iowa Nov 2020"),
                                         expression("5.4 % \n Alabama Jan 2021")))

# clean up tau_setting column
conf_int$tau_setting <- gsub("_", " ", conf_int$tau_setting)
conf_int$tau_labels <- factor(conf_int$tau_setting, 
                              levels = c("Children child index", 
                                         "Healthcare", 
                                         "Household spouses",
                                         "Household asymptomatic index", 
                                         "Household symptomatic index"
                                         ),
                              labels = c(expression("From Child Index Case"),
                                         expression("Healthcare Setting"),
                                         expression("Spouses"),
                                         expression("Household \n (Asymptomatic Index Case)"), 
                                         expression("Household \n (Symptomatic Index Case)")
                                         
                                         ))
```

## Sensitivity
```{r}
indiv_sens <- data.frame(sens_fxn(1))$mean
# Fixed and Tau Graph Effect
## no sampling from prevalence
## so don't need confidence interval on the null model (Null Model (Fixed))
sens_plots_pifixed <- lapply(types[c(4, 6)], function(i){ # Fixed and Tau Graph Effect
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_sens)) +
    geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
    geom_line(data=conf_int[conf_int$type == "Null Model (Fixed)",], aes(linetype = "No Correlation"))+
    geom_hline(aes(yintercept=indiv_sens, linetype = "Individual Testing"), color = "grey35")+
    geom_hline(aes(yintercept=0.85, linetype = "FDA Threshold"), color = "grey35")+
    facet_wrap(~ prev_labels) +
    geom_ribbon(data = . %>% filter(type==i), 
                aes(x=pool_size, ymin = sens_q025, ymax = sens_q975, 
                    fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
    scale_linetype_manual(values = lines_sensplots) +
    theme_bw() + 
    labs(x = "Pool Size", y = "Sensitivity", linetype = lines) +
    #ggtitle(i) +
    guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 
})


# Pi Graph Effect and All Graph Effect
## sample from prevalence
## so need confidence interval on the null model (Null Model (Pi Graph Effect))
sens_plots_pigraph <- lapply(types[c(3, 5)], function(i){
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_sens)) +
  geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
  geom_line(data=conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], aes(linetype = "No Correlation"))+
    geom_hline(aes(yintercept=indiv_sens, linetype = "Individual Testing"), color = "grey35")+
    geom_hline(aes(yintercept=0.85, linetype = "FDA Threshold"), color = "grey35")+
  facet_wrap(~ prev_labels) +
  geom_ribbon(data = . %>% filter(type==i), aes(x=pool_size, ymin = sens_q025, ymax = sens_q975, 
                                                fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
  geom_ribbon(data = conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], 
              aes(x=pool_size, ymin = sens_q025, ymax = sens_q975, 
                  fill = tau_labels), show.legend = F, alpha = 0.07, colour = NA)+
  scale_linetype_manual(values = lines_sensplots) +
  theme_bw() + 
  labs(x = "Pool Size", y = "Sensitivity", linetype = lines) +
  #ggtitle(i) +
  guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 
})

pdf(file.path(path.out.figures, "sens_plots_pifixed_062.pdf"), width=8, height=5)
sens_plots_pifixed
dev.off()

png(file.path(path.out.figures, "sens_plots_pifixed_062.png"), units = "in", width = 8, height = 5, 
    res=300)
sens_plots_pifixed
dev.off()

pdf(file.path(path.out.figures, "sens_plots_pigraph_062.pdf"), width=8, height=5)
sens_plots_pigraph
dev.off()

png(file.path(path.out.figures, "sens_plots_pigraph_062.png"), units = "in", width = 8, height = 5, 
    res=300)
sens_plots_pigraph
dev.off()

```


## Relative Sensitivity
```{r}
relsens_plots_pifixed <- lapply(types[c(4, 6)], function(i){ # Fixed and Tau Graph Effect
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_ppa)) +
    geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
    geom_line(data=conf_int[conf_int$type == "Null Model (Fixed)",], aes(linetype = "No Correlation"))+
    geom_hline(aes(yintercept=1, linetype = "Individual Testing"), color = "grey35")+
    facet_wrap(~ prev_labels) +
    geom_ribbon(data = . %>% filter(type==i), 
                aes(x=pool_size, ymin = ppa_q025, ymax = ppa_q975, 
                    fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
    scale_linetype_manual(values = lines_sensplots) +
    theme_bw() + 
    labs(x = "Pool Size", y = "Relative Sensitivity", linetype = lines) +
    guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 
})

relsens_plots_pigraph <- lapply(types[c(3, 5)], function(i){
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_ppa)) +
  geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
  geom_line(data=conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], aes(linetype = "No Correlation"))+
  geom_hline(aes(yintercept=1, linetype = "Individual Testing"), color = "grey35")+
  facet_wrap(~ prev_labels) +
  geom_ribbon(data = . %>% filter(type==i), aes(x=pool_size, ymin = ppa_q025, ymax = ppa_q975, 
                                                fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
  geom_ribbon(data = conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], 
              aes(x=pool_size, ymin = ppa_q025, ymax = ppa_q975, 
                  fill = tau_labels), show.legend = F, alpha = 0.07, colour = NA)+
  scale_linetype_manual(values = lines_sensplots) +
  theme_bw() + 
  labs(x = "Pool Size", y = "Relative Sensitivity", linetype = lines) +
  guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), 
         linetype=guide_legend(title="Model Type")) 
})

pdf(file.path(path.out.figures, "relsens_plots_pifixed_062.pdf"), width=8, height=5)
relsens_plots_pifixed
dev.off()

png(file.path(path.out.figures, "relsens_plots_pifixed_062.png"), units = "in", width = 8, height = 5, 
    res=300)
relsens_plots_pifixed
dev.off()

pdf(file.path(path.out.figures, "relsens_plots_pigraph_062.pdf"), width=8, height=5)
relsens_plots_pigraph
dev.off()

png(file.path(path.out.figures, "relsens_plots_pigraph_062.png"), units = "in", width = 8, height = 5, 
    res=300)
relsens_plots_pigraph
dev.off()
```
## Tests
```{r}
tests_plots_pifixed <- lapply(types[c(4, 6)], function(i){ # Fixed and Tau Graph Effect
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_tests)) +
    geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
    geom_line(data=conf_int[conf_int$type == "Null Model (Fixed)",], aes(linetype = "No Correlation"))+
    geom_hline(aes(yintercept=1, linetype = "Individual Testing"), color = "grey35")+
    facet_wrap(~ prev_labels) +
    geom_ribbon(data = . %>% filter(type==i), 
                aes(x=pool_size, ymin = tests_q025, ymax = tests_q975, 
                    fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
    scale_linetype_manual(values = lines_sensplots) +
    theme_bw() + 
    labs(x = "Pool Size", y = "Tests per Sample", linetype = lines) +
    guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 
})

tests_plots_pigraph <- lapply(types[c(3, 5)], function(i){
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_tests)) +
  geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
  geom_line(data=conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], aes(linetype = "No Correlation"))+
  geom_hline(aes(yintercept=1, linetype = "Individual Testing"), color = "grey35")+
  facet_wrap(~ prev_labels) +
  geom_ribbon(data = . %>% filter(type==i), aes(x=pool_size, ymin = tests_q025, ymax = tests_q975, 
                                                fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
  geom_ribbon(data = conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], 
              aes(x=pool_size, ymin = tests_q025, ymax = tests_q975, 
                  fill = tau_labels), show.legend = F, alpha = 0.07, colour = NA)+
  scale_linetype_manual(values = lines_sensplots) +
  theme_bw() + 
  labs(x = "Pool Size", y = "Tests per Sample", linetype = lines) +
  guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), 
         linetype=guide_legend(title="Model Type")) 
})

pdf(file.path(path.out.figures, "tests_plots_pifixed_062.pdf"), width=8, height=5)
tests_plots_pifixed
dev.off()

png(file.path(path.out.figures, "tests_plots_pifixed_062.png"), units = "in", width = 8, height = 5, 
    res=300)
tests_plots_pifixed
dev.off()

pdf(file.path(path.out.figures, "tests_plots_pigraph_062.pdf"), width=8, height=5)
tests_plots_pigraph
dev.off()

png(file.path(path.out.figures, "tests_plots_pigraph_062.png"), units = "in", width = 8, height = 5, 
    res=300)
tests_plots_pigraph
dev.off()

```
## Missed Cases
```{r}
missed_plots_pifixed <- lapply(types[c(4, 6)], function(i){ # Fixed and Tau Graph Effect
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_missed)) +
    geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
    geom_line(data=conf_int[conf_int$type == "Null Model (Fixed)",], aes(linetype = "No Correlation"))+
    facet_wrap(~ prev_labels) +
    geom_ribbon(data = . %>% filter(type==i), 
                aes(x=pool_size, ymin = missed_q025, ymax = missed_q975, 
                    fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
    scale_linetype_manual(values = lines) +
    theme_bw() + 
    labs(x = "Pool Size", y = "Missed Cases per Sample", linetype = lines) +
    guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 
})

missed_plots_pigraph <- lapply(types[c(3, 5)], function(i){
  ggplot(conf_int %>% filter(type == i), aes(x=pool_size, y= mean_missed)) +
  geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
  geom_line(data=conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], aes(linetype = "No Correlation"))+
  facet_wrap(~ prev_labels) +
  geom_ribbon(data = . %>% filter(type==i), aes(x=pool_size, ymin = missed_q025, ymax = missed_q975, 
                                                fill = tau_labels), show.legend = F, alpha = 0.2, colour = NA)+
  geom_ribbon(data = conf_int[conf_int$type == "Null Model (Pi Graph Effect)",], 
              aes(x=pool_size, ymin = missed_q025, ymax = missed_q975, 
                  fill = tau_labels), show.legend = F, alpha = 0.07, colour = NA)+
  scale_linetype_manual(values = lines) +
  theme_bw() + 
  labs(x = "Pool Size", y = "Missed Cases per Sample", linetype = lines) +
  guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), 
         linetype=guide_legend(title="Model Type")) 
})

pdf(file.path(path.out.figures, "missed_plots_pifixed_062.pdf"), width=8, height=5)
missed_plots_pifixed
dev.off()

png(file.path(path.out.figures, "missed_plots_pifixed_062.png"), units = "in", width = 8, height = 5, 
    res=300)
missed_plots_pifixed
dev.off()

pdf(file.path(path.out.figures, "missed_plots_pigraph_062.pdf"), width=8, height=5)
missed_plots_pigraph
dev.off()

png(file.path(path.out.figures, "missed_plots_pigraph_062.png"), units = "in", width = 8, height = 5, 
    res=300)
missed_plots_pigraph
dev.off()

```


# combined plot by graph type
```{r}
allgraph_combined_a <- ggarrange(
  tests_plots_pigraph[[1]], 
  missed_plots_pigraph[[1]], 
  ncol = 2, 
  common.legend = TRUE, legend = "right")
#sens_plots_pigraph[[1]], #+labs(x="") 
#relsens_plots_pigraph[[1]], #+labs(x="", y="Relative Sensitivity") 

pdf(file.path(path.out.figures, "combined_allgraph_plots_a.pdf"), width=10, height=5)
allgraph_combined_a
dev.off()

png(file.path(path.out.figures, "combined_allgraph_plots_a.png"), units = "in", width = 10, height = 5, 
    res=300)
allgraph_combined_a
dev.off()

allgraph_combined_b <- ggarrange(
  sens_plots_pigraph[[1]]+labs(x=""),
  relsens_plots_pigraph[[1]]+labs(x=""),
  tests_plots_pigraph[[1]], 
  missed_plots_pigraph[[1]], 
  nrow = 2, ncol = 2, 
  common.legend = TRUE, legend = "right")

pdf(file.path(path.out.figures, "combined_allgraph_plots_b.pdf"), width=10, height=10)
allgraph_combined_b
dev.off()

png(file.path(path.out.figures, "combined_allgraph_plots_b.png"), units = "in", width = 10, height = 10, 
    res=300)
allgraph_combined_b
dev.off()

fixed_combined <- ggarrange(
  sens_plots_pifixed[[1]]+labs(x=""),
  relsens_plots_pifixed[[1]]+labs(x=""),
  tests_plots_pifixed[[1]], 
  missed_plots_pifixed[[1]], 
  nrow = 2, ncol = 2, 
  common.legend = TRUE, legend = "right")

pdf(file.path(path.out.figures, "combined_fixed_plots.pdf"), width=10, height=10)
fixed_combined
dev.off()

png(file.path(path.out.figures, "combined_fixed_plots.png"), units = "in", width = 10, height = 10, 
    res=300)
fixed_combined
dev.off()

pigraph_combined <- ggarrange(
  sens_plots_pigraph[[2]]+labs(x=""),
  relsens_plots_pigraph[[2]]+labs(x=""),
  tests_plots_pigraph[[2]], 
  missed_plots_pigraph[[2]], 
  nrow = 2, ncol = 2, 
  common.legend = TRUE, legend = "right")

pdf(file.path(path.out.figures, "combined_pigraph_plots.pdf"), width=10, height=10)
pigraph_combined
dev.off()

png(file.path(path.out.figures, "combined_pigraph_plots.png"), units = "in", width = 10, height = 10, 
    res=300)
pigraph_combined
dev.off()

taugraph_combined <- ggarrange(
  sens_plots_pifixed[[2]]+labs(x=""),
  relsens_plots_pifixed[[2]]+labs(x=""),
  tests_plots_pifixed[[2]], 
  missed_plots_pifixed[[2]], 
  nrow = 2, ncol = 2, 
  common.legend = TRUE, legend = "right")

pdf(file.path(path.out.figures, "combined_taugraph_plots.pdf"), width=10, height=10)
taugraph_combined
dev.off()

png(file.path(path.out.figures, "combined_taugraph_plots.png"), units = "in", width = 10, height = 10, 
    res=300)
taugraph_combined
dev.off()


```
# FDA Sensitivity Threshold
```{r}
conf_int2 <- conf_int %>% 
  mutate(sens_fda_dodge = ifelse(type != "Null Model (Pi Graph Effect)" & tau_setting == "Household symptomatic index", 
                                 sens_fda + 0.015,
                                 ifelse(type != "Null Model (Pi Graph Effect)" & tau_setting == "Children child index",
                                        sens_fda - 0.015, 
                                        sens_fda)))


sens_fda_plots <- ggplot(conf_int2 %>% filter(type == "All Graph Effect"), aes(x=pool_size, y= sens_fda_dodge)) +
  geom_line(aes(color=tau_labels, linetype = "Network Transmission")) +
  geom_line(data=conf_int2[conf_int2$type == "Null Model (Pi Graph Effect)",], aes(linetype = "No Correlation"))+
  facet_wrap(~ prev_labels) +
  scale_linetype_manual(values = lines_sensplots) +
  theme_bw() + 
  labs(x = "Pool Size", y = expression(paste("Proportion with Sensitivity", "\u2265", "0.85")), linetype = lines) +
  #ggtitle(i) +
  guides(color=guide_legend(title=expression(paste("Transmission (", tau, ")"))), linetype=guide_legend(title="Model Type")) 

pdf(file.path(path.out.figures, "sens_fda_allgraph.pdf"), width=8, height=5)
sens_fda_plots
dev.off()

png(file.path(path.out.figures, "sens_fda_allgraph.png"), units = "in", width = 8, height = 5, 
    res=300)
sens_fda_plots
dev.off()
```



# ---- Other Analysis ------ #
## Area under the Curve: tests per sample vs. efficiency
Objective: minimize tests per sample, maximize sensitivity

Expected number of tests per sample is defined as follows:
$$
 \eta =  \frac{1}{n} \times \mathbb{E}[1 + n \times \mathbb{P}[\text{test is positive}]  ] = \frac{1}{n} + \mathbb{P}[\text{test is positive}] = \frac{1}{n} + \sum_{k=1}^n \mathbb{P}[\text{test is positive} |\sum_i Y_i =k] p_k
$$
We want to minimize tests per sample
Transform to a quantity that we want to maximize, e.g. number of tests saved per pool of size $n$
$$
n -(n\times \eta) = n \times(1-\eta)
$$
However this transformation depends on pool size and we want the x-axis to be independent of pool size. 

not sure which transformation is better
```{r}
# Trying different transformations
ggplot(conf_int %>% filter(type== "Fixed" & prev==0.02 & tau==0.2)) +
  geom_point(aes(x=pool_size*(1-mean_tests), y = mean_sens,color=factor(pool_size)))+
  ggtitle("Fixed Model, Prev=0.02, Tau=0.2")

ggplot(conf_int %>% filter(type== "Fixed" & prev==0.02), 
       aes(x=pool_size*(1-mean_tests), y = mean_sens,
           color=factor(tau))) +
  geom_point()+
  ggtitle("Fixed Model, Prev=0.02")

ggplot(conf_int %>% filter(type== "Fixed" & prev==0.02 & tau==0.2)) +
  geom_point(aes(x=(1+pool_size)-mean_tests, y = mean_sens, color=pool_size))+
  ggtitle("Fixed Model, Prev=0.02, Tau=0.2")

ggplot(conf_int %>% filter(type== "Fixed" & prev==0.02 & tau==0.2)) +
  geom_point(aes(x=mean_sens, y = -sign(1-mean_tests)*(1-mean_tests), color=pool_size))+
  ggtitle("Fixed Model, Prev=0.02, Tau=0.2")

```

```{r}
table(conf_int$prev)
# 2-mean_tests is the transformation we want
# trajectory of relative difference with tau=0
fixed_only <- conf_int %>% 
  filter(type=="Fixed" | type == "Null Model (Fixed)") %>%
  group_by(pool_size, prev) %>%
  mutate(tau0delta_sens = mean_sens - mean_sens[type=="Null Model (Fixed)"], 
         tau0delta_tests = (mean_tests[type=="Null Model (Fixed)"] - mean_tests)) %>% 
  filter(type == "Fixed") %>%
  dplyr::select(type, pool_size, tau, prev, tau_labels, prev_labels, tau0delta_sens, tau0delta_tests)

# indiv_dat <- expand.grid(tau = unique(conf_int$tau), prev = unique(conf_int$prev))
# indiv_dat$sens <- data.frame(sens_fxn(1))$mean
# indiv_dat$tests <- 1
# indiv_dat$type <- "Individual Testing"


 sens.v.tests2 <- ggplot(fixed_only %>% filter(prev==0.013), 
       aes(x=tau0delta_tests, y = tau0delta_sens, 
                color=tau_labels)) +
  geom_point(aes(size=pool_size), alpha=0.6)+
   labs(x="Mean Tests per Sample- Mean Tests per Sample[tau=0]", 
        y="Mean Sensitivity - Mean Sensitivity[tau=0] ")+
  guides(color=guide_legend(title="Tau"), 
         size=guide_legend(title="Pool Size"))+
  ggtitle("Delta Tau=0 Model, Sensitivity vs Tests/Sample, Fixed Model, Prev=0.02")+
  theme_bw()
 
pdf(file.path(path.out.figures, "sens.v.tests_plots_062.pdf"),width=8, height=8)  
ggarrange(sens.v.tests1, sens.v.tests2, 
          nrow=1, ncol=1,
          common.legend = TRUE, legend = "right")
dev.off()

```



```{r}
library(zoo) #AUC fxn

calc_AUC <- function(df, prevtau_grid, prev_i, tau_i){
  
  get_AUC <- function(prev_i, tau_i){
    dat <- df %>% 
      filter(type=="Fixed" & prev==prev_i & tau==tau_i)
    #mutate(test_transf1= 
    #test_transf1 = (1+pool_size)-mean_tests, 
    #test_transf2 = pool_size*(1-mean_tests))
    x <-  dat$tau0delta_tests
    y <- dat$tau0delta_sens
    id <- order(x)
    
    AUC <- sum(diff(x[id])*rollmean(y[id],2))
    #https://stackoverflow.com/questions/4954507/calculate-the-area-under-a-curve
  }
  mapply(get_AUC, prev_i= prevtau_grid$prev_i, tau_i= prevtau_grid$tau_i)
  
}

#calc_AUC(prev_i=0.02, tau_i=0.2)


prevtau_grid <- expand.grid(prev_i=unique(conf_int$prev), tau_i=unique(conf_int$tau))

aucs <- calc_AUC(fixed_only, prevtau_grid, prev_i= prevtau_grid$prev_i, tau_i= prevtau_grid$tau_i)
aucs <- cbind(prevtau_grid, aucs)

aucs_perfect <- calc_AUC(perfect_fixed_only, prevtau_grid, prev_i= prevtau_grid$prev_i, tau_i= prevtau_grid$tau_i)

all_auc <- cbind(prevtau_grid, aucs, aucs_perfect)
ggplot(aucs)+
  geom_point(aes(x=prev_i, y=aucs, color=factor(tau_i)))+
  ggtitle("AUC of Sensitivity vs. Tests Relative to Tau=0")+
  theme_bw()

pdf(file.path(path.out.figures, "auc_sens.v.tests_plots.pdf"),width=8, height=5)  
ggplot(all_auc)+
  geom_point(aes(x=prev_i, y=aucs, color=factor(tau_i)))+
  ggtitle("AUC of Sensitivity vs. Tests Relative to Tau=0")+
  theme_bw()
dev.off()
```

TODO: summary table
for this prevalence, tau, pool size quantify efficiency relative to individual testing
percent increase in sensitivity comapred to null model
```{r}
library(dplyr)
summary_table <- conf_int %>% 
  group_by(pool_size, prev, tau) %>%
  mutate(sens_pct_change = ((mean_sens - mean_sens[type=="Null Model (Fixed)"])/mean_sens[type=="Null Model (Fixed)"])*100, 
         test_pct_change= (1-mean_tests)*100) %>%
    dplyr::filter(pool_size == 5 | pool_size == 20) %>%
  dplyr::select(type, pool_size, prev, tau, 
                prev_labels, tau_labels,
                mean_sens, sens_pct_change,
                mean_tests, test_pct_change)

write.csv(summary_table, "summarytable_sens_tests.csv")

temp <- read.csv("summarytable_sens_tests.csv")

temp2 <- temp %>% filter(prev == 0.002 | prev == 0.054 ) %>%
  filter( type == "All Graph Effect" | type == "Tau Graph Effect") %>%
  filter(tau == 0.012 | tau==0.18 | tau==0.377)
```




## -------------------------------------------------------------------------##
### Visualize probability data
### Distance (KL) between Null distribution and alternative models
Compute a distance metric (e.g. EMD distance, KL divergence, Kolmogorov Smirnov) between distributions (binomial (null) vs. the alternative probability distributions). Make a heat map or curve as function of tau 

For these plots to work, need to repeat the simulation using a much finer scale grid for prevalence and tau (otherwise there are too few points to plot)- e.g. prev from 0.005 to 0.195 by increments of 0.01, tau from 0 to 0.6 by increments of 0.1.
```{r}
#prob_dat_long <- read.csv("simprobs_may4.csv")
# convert to wide format
# take median of the simulations for each combination of poolsize, prev, 
# tau, num pos and type
prob_dat_wide <- dcast(prob_dat_long, pool_size + prev + tau + num_pos ~ type, 
                       value.var= "prob_pos", 
                       fun.aggregate = median)
colnames(prob_dat_wide) <- c("pool_size", "prev", "tau", "num_pos",
                             "All_Graph_Effect", "Fixed", "Null_Model_Fixed", 
                             "Null_Model_Pi_Graph",
                             "Pi_Graph_Effect", "Tau_Graph_Effect")

# KL divergence as a function of transmission (tau) and prevalence (pi)
# for specific pool sizes
library(flexmix) # contains KLdiv fxn
it=1
for (s in 1:length(unique(prob_dat_wide$pool_size))){
  tdat <- prob_dat_wide %>% filter(pool_size == unique(prob_dat_wide$pool_size)[s]) 
  for (p in 1:length(unique(prob_dat_wide$prev))){
    for (t in 1:length(unique(prob_dat_wide$tau))){
      dat_temp <- tdat %>% 
        filter(prev == unique(prob_dat_wide$prev)[p] & 
                 tau == unique(prob_dat_wide$tau)[t])
      div <- data.frame(KLdiv(as.matrix(dat_temp %>% dplyr::select(All_Graph_Effect,
                                                                   Tau_Graph_Effect,
                                                                   Pi_Graph_Effect, Fixed,
                                                                   Null_Model_Fixed,
                                                                   Null_Model_Pi_Graph)) ))
      if (it == 1){
        div_all <- div %>% 
          dplyr::select(Null_Model_Fixed) %>%
          mutate(type = colnames(div), 
                 pool_size = unique(prob_dat_wide$pool_size)[s],
                 prev = unique(prob_dat_wide$prev)[p], 
                 tau = unique(prob_dat_wide$tau)[t]) %>%
          filter(type != "Null_Model_Fixed")
      }else{
        div <- div %>% 
          dplyr::select(Null_Model_Fixed) %>%
          mutate(type = colnames(div), 
                 pool_size = unique(prob_dat_wide$pool_size)[s],
                 prev = unique(prob_dat_wide$prev)[p], 
                 tau = unique(prob_dat_wide$tau)[t]) %>%
          filter(type != "Null_Model_Fixed")
        div_all <- rbind(div_all, div)
      }
      it = it + 1
    }
  }
}


```

```{r}
# Plot KL Divergence for Probability Distributions for each model type
div_all$type <- factor(div_all$type, 
                       levels = c("Fixed","Pi_Graph_Effect", "Tau_Graph_Effect", 
                                  "All_Graph_Effect", "Null_Model_Pi_Graph"))

# all in one plot
pdf(file.path(path.out.figures, "KL_div_all.pdf"),width=8, height=5)  
ggplot(div_all %>% filter(pool_size %in% c(2,5,10,20)), aes(x=prev, y=tau, fill=Null_Model_Fixed))+
  geom_tile() + 
  scale_fill_gradientn(colours = rainbow(5), values = c(0,0.1, 1))+
  # can try rainbow(6), etc to see different levels of granularity in plot
  facet_grid(pool_size~type) + 
  scale_x_continuous(limits=c(0,.21), breaks=c(0, .1, .2))+
  theme_light()+
  guides(fill=guide_colourbar(title="KL Divergence \n from Null Model")) + 
  xlab(expression(paste("Prevalence (", pi, ")"))) + 
  ylab(expression(paste("Network Transmission (", tau, ")"))) +
  ggtitle(paste("KL Divergence from Null Model, by Model Type and Pool Size"))
dev.off()

# separate plots for each model type
pdf(file.path(path.out.figures, "KL_div_fixed.pdf"),width=8, height=5)  
ggplot(div_all  %>% filter(type == "Fixed"), aes(x=prev, y=tau, fill=Null_Model))+
  geom_tile() + 
  scale_fill_gradientn(colours = rainbow(5), values = c(0,0.1, 1))+
  facet_wrap(~pool_size) + 
  # facet_grad(~pool_size)
  scale_x_continuous(limits=c(0,.21), breaks=c(0, .1, .2))+
  theme_light()+
  guides(fill=guide_colourbar(title="KL Divergence \n from Null Model")) + 
  xlab(expression(paste("Prevalence (", pi, ")"))) + 
  ylab(expression(paste("Network Transmission (", tau, ")"))) +
  ggtitle(paste("KL Divergence between Null and Fixed Models by Pool Size"))
dev.off()
```








